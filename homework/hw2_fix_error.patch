Index: homework/src/HW2/FCFS.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/FCFS.java	(date 1489030227000)
+++ homework/src/HW2/FCFS.java	(date 1489043713000)
@@ -208,11 +208,19 @@
     }
 
     public static void main(String[] args) throws IOException {
-        // input format: FCFS [--verbose] input-1.txt
+        // input format: java FCFS [--verbose] input-1.txt
+        //java HW2/FCFS /Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-6.txt
         String filename = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-6.txt";
 
-        String inputString = new String(Files.readAllBytes(Paths.get(filename)), StandardCharsets.UTF_8);
+        if(args.length == 2){
+            if(args[0].equals("--verbose")){
 
+            }
+        }else if(args.length == 1){ // java FCFS input-6.txt
+            filename = args[0];
+        }
+
+        String inputString = new String(Files.readAllBytes(Paths.get(filename)), StandardCharsets.UTF_8);
         FCFS newscheduler = new FCFS(inputString);
         System.out.println("The original input was: "+inputString);
         newscheduler.sortProcessesByArrivalTime();
Index: homework/src/HW2/Process_RR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/Process_RR.java	(date 1489030227000)
+++ homework/src/HW2/Process_RR.java	(date 1489043713000)
@@ -1,21 +1,25 @@
 package HW2;
 
+
 /**
  * Created by lizichen1 on 3/6/17.
  */
 public class Process_RR {
 
+
     int A, B, C, M;
-    int id;
+
     int state; // 0 - unstarted, 1 - ready, 2 - running, 3 - blocked, 4 - terminated.
 
     int timeRemaining;              // time remaining for the process to terminate
     int blockLeft;                  // time until the process back to ready
+
     int burstTotal;                 // The total time of the CPU burst (used to calculate IO block time)
     int cpuBurstRemaining;
 
     int total_ioTime;
     int total_ReadyState_Time;
+
     int finishTime;                 // finishTime =  C + total_ioTime + total_ReadyState_Time + A
     int turnaroundTime;             // finishTime - A
 
@@ -41,27 +45,6 @@
         this.quantumMax = 1000;
     }
 
-    public void setTimeRemaining(int timeRemaining) {
-        this.timeRemaining = timeRemaining;
-    }
-
-    public void setQuantumMax(int quantum) {
-        this.quantumMax = quantum;
-    }
-
-    public int getState() {
-        return state;
-    }
-
-    public void setToRun(int cpuBurst)  {
-        this.state = 2;
-
-        if(this.cpuBurstRemaining <= 0) {
-            this.burstTotal = cpuBurst;
-            this.cpuBurstRemaining = cpuBurst;
-        }
-    }
-
     public void tick()  {
         switch (state) {
             case 0:
@@ -82,6 +65,14 @@
         }
     }
 
+    public void setToRun(int cpuBurst)  {
+        this.state = 2;
+        if(this.cpuBurstRemaining <= 0) {
+            this.burstTotal = cpuBurst;
+            this.cpuBurstRemaining = cpuBurst;
+        }
+    }
+
     private void handleRunTick()  {
         if (cpuBurstRemaining >= 0) {
             timeRemaining--;
@@ -107,32 +98,20 @@
         }
     }
 
-    public String results() {
+    public String summary() {
         finishTime = this.C + total_ioTime + total_ReadyState_Time + this.A;
         turnaroundTime = finishTime - A;
 
         StringBuilder sb = new StringBuilder();
+
         sb.append("        ");
         sb.append(String.format("(A, B, C, M) = (%d, %d, %d, %d)", this.A, this.B, this.C, this.M));
-        sb.append("\n        ");
-        sb.append("Finishing time: " + finishTime);
-        sb.append("\n        ");
-        sb.append("Turnaround time: " + turnaroundTime);
-        sb.append("\n        ");
-        sb.append("I/O time: " + total_ioTime);
-        sb.append("\n        ");
+        sb.append(Utils.NEWLINE_SPACE);
+        sb.append("Finishing time: " + finishTime + Utils.NEWLINE_SPACE);
+        sb.append("Turnaround time: " + turnaroundTime + Utils.NEWLINE_SPACE);
+        sb.append("I/O time: " + total_ioTime + Utils.NEWLINE_SPACE);
         sb.append("Waiting time: " + total_ReadyState_Time);
+
         return sb.toString();
     }
-
-    public int getA() { return this.A; }
-    public int getB() { return this.B; }
-    public int getC() { return this.C; }
-    public int getM() { return this.M; }
-    public int getBlockLeft() { return this.blockLeft; }
-    public int getCpuBurstRemaining() { return this.cpuBurstRemaining; }
-    public int getTotal_ReadyState_Time() { return this.total_ReadyState_Time; }
-    public int getFinishTime() { return this.finishTime; }
-
-    public int getTurnaroundTime() { return this.turnaroundTime; }
 }
Index: homework/src/HW2/RR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/RR.java	(date 1489030227000)
+++ homework/src/HW2/RR.java	(date 1489043713000)
@@ -21,7 +21,7 @@
     private static List<String> processList;
     private static int numberOfProcesses;
     private static ArrayList<Process_RR> allProcesses;
-    protected ArrayList<Process_RR> terminated;
+    //protected ArrayList<Process_RR> terminated;
 
     public RR(ArrayList<Process_RR> processes, int quantum, boolean verbose, int numberOfProcesses) throws FileNotFoundException {
         super(verbose, processes);
@@ -31,7 +31,7 @@
         this.allProcesses = processes;
 
         for (Process_RR p : processes) {
-            p.setQuantumMax(2);
+            p.quantumMax = 2;
         }
     }
 
@@ -60,10 +60,27 @@
 
     public static void main(String[] args){
 
-        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-6.txt";
+        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-7.txt";
         int quantum = 2;
         boolean verbose = true;
 
+        // java RR --verbose input-6.txt
+        // java RR input-6.txt
+        if(args.length == 2){
+            if(args[0].equals("--verbose")){
+                verbose = true;
+                input = args[1];
+            }
+            else{
+                verbose = false;
+                System.out.println("Please type\n java RR --verbose input.txt or java RR input.txt");
+                System.exit(-1);
+            }
+        }else if(args.length == 1){
+            input = args[0];
+            verbose = false;
+        }
+
         try {
 
             File inFile = new File(input);
@@ -86,8 +103,9 @@
 
             RR rr = new RR(allprocess, quantum, verbose, numberOfProcesses);
 
-            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + rr.getOriginalProcesses());
-            System.out.println(Utils.THE_SORTED_INPUT_WAS + rr.getSortedProcesses());
+            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + rr.originalProcesses);
+            System.out.println(Utils.THE_SORTED_INPUT_WAS + rr.sortedProcesses);
+
             System.out.println();
 
             while (rr.incomplete()) {
Index: homework/src/HW2/RR_Scheduler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/RR_Scheduler.java	(date 1489030227000)
+++ homework/src/HW2/RR_Scheduler.java	(date 1489043713000)
@@ -11,6 +11,14 @@
  */
 public abstract class RR_Scheduler {
 
+    public static final int LARGE_QUANTUM_INTEGER = 99999;
+    public static final String RESET_BURST_TO_ZERO = "0";
+
+
+    int quantum;
+
+    private int totalIoBlockCycles;
+
     public static final String BEFORE_CYCLE_4S = "Before Cycle \t%4s:";
 
     ArrayList<Process_RR> processes;
@@ -19,7 +27,8 @@
     int cycleNum;
     boolean verbose;
     boolean noProcessRunning;
-    String name;
+
+
     String originalProcesses;
     String sortedProcesses;
 
@@ -29,69 +38,50 @@
     LinkedList<Process_RR> blockedList;
     ArrayList<Process_RR> terminated;
 
-    int quantum;
 
-    private int totalIoBlockCycles;
 
-
     public RR_Scheduler(boolean verbose, ArrayList<Process_RR> processes) throws FileNotFoundException {
+
+        this.verbose = verbose;
+
         this.processes = new ArrayList();
 
-        File file = new File("input/random-numbers");
+        File file = new File(Utils.RANDOM_NUMBER_FILE);
         random_integers = new Scanner(file);
 
-
         cycleNum = 0;
-        this.verbose = verbose;
+
         this.numProcesses = processes.size();
-        this.originalProcesses = processStringFromList(this.numProcesses, processes);
+        this.originalProcesses = getProcessInfo(this.numProcesses, processes);
         this.processes = sort(processes);
-        this.sortedProcesses = processStringFromList(this.numProcesses, this.processes);
+        this.sortedProcesses = getProcessInfo(this.numProcesses, this.processes);
         this.unstarted = processes;
         noProcessRunning = true;
 
-
         this.ready = new LinkedList();
         this.readyQueue = new LinkedList();
         this.blockedList = new LinkedList();
         this.terminated = new ArrayList();
 
-
         this.totalIoBlockCycles = 0;
-        this.quantum = 99999;
+        this.quantum = LARGE_QUANTUM_INTEGER;
     }
 
-    protected static String processStringFromList(int numProcesses, ArrayList<Process_RR> list) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(numProcesses + " ");
+    public static String getProcessInfo(int numProcesses, ArrayList<Process_RR> list) {
+        StringBuilder stringBuilder = new StringBuilder();
+        stringBuilder.append(numProcesses + " ");
         for (int i = 0; i < list.size(); i++) {
-            sb.append("(");
+            stringBuilder.append("(");
             Process_RR p = list.get(i);
-            sb.append(p.getA() + " ");
-            sb.append(p.getB() + " ");
-            sb.append(p.getC() + " ");
-            sb.append(p.getM());
-            sb.append(") ");
+            stringBuilder.append(p.A + " ");
+            stringBuilder.append(p.B + " ");
+            stringBuilder.append(p.C + " ");
+            stringBuilder.append(p.M);
+            stringBuilder.append(") ");
         }
-        return sb.toString();
+        return stringBuilder.toString();
     }
 
-    protected ArrayList<Process_RR> sort(ArrayList<Process_RR> processes){
-        Collections.sort(processes, new Comparator<Process_RR>() {
-            public int compare(Process_RR process_A, Process_RR process_B) {
-                int arrivalA = process_A.A;
-                int arrivalB = process_B.A;
-                if (arrivalA > arrivalB)
-                    return 1;
-                else if (arrivalA < arrivalB)
-                    return -1;
-                else
-                    return 0;
-            }
-        });
-        return processes;
-    }
-
     // call for each cycle
     public void cycle() {
         if(verbose)
@@ -111,7 +101,7 @@
         if (noProcessRunning && !readyQueue.isEmpty()) {
             Process_RR p = readyQueue.removeLast();
             if (cycleNum == 17) {
-                int random = randomOS(p.getB());
+                int random = randomOS(p.B);
                 p.setToRun(random);
             }
             else {
@@ -119,14 +109,13 @@
                     p.state = 2;
                 }
                 else {
-                    int random = randomOS(p.getB());
+                    int random = randomOS(p.B);
                     p.setToRun(random);
                 }
             }
         }
     }
 
-    protected abstract void updateReadyQueue(); // Abstract method for specific scheduling algorithm to implement
 
     public boolean incomplete() {
         return (terminated.size() < numProcesses);
@@ -137,9 +126,9 @@
         boolean atLeastOneBlocked = false;
         for (Process_RR p : processes) {
 
-            int state = p.getState();
+            int state = p.state;
 
-            if (state == 0 && cycleNum >= p.getA()) {
+            if (state == 0 && cycleNum >= p.A) {
                 p.state = 1;
                 this.ready.add(p);
             }
@@ -171,101 +160,102 @@
         StringBuilder sb = new StringBuilder();
         sb.append(String.format(BEFORE_CYCLE_4S, cycleNum));
         for (Process_RR p : processes) {
-            int state = p.getState();
+            int state = p.state;
             String stateName;
             String burst;
-            switch (state) {
-                case 0:
+            if(state == 0){
-                    stateName = Utils.UNSTARTED;
+                stateName = Utils.UNSTARTED;
-                    burst = "0";
-                    break;
-                case 1:
+                burst = RESET_BURST_TO_ZERO;
+            }else if(state == 1){
-                    stateName = Utils.READY;
+                stateName = Utils.READY;
-                    burst = "0";
-                    break;
-                case 2:
+                burst = RESET_BURST_TO_ZERO;
+            } else if (state == 2) {
-                    stateName = Utils.RUNNING;
+                stateName = Utils.RUNNING;
-                    burst = String.valueOf(p.getCpuBurstRemaining());
-                    break;
-                case 3:
+                burst = String.valueOf(p.cpuBurstRemaining);
+            } else if(state == 3){
-                    stateName = Utils.BLOCKED;
+                stateName = Utils.BLOCKED;
-                    burst = String.valueOf(p.getBlockLeft());
-                    break;
-                case 4:
+                burst = String.valueOf(p.blockLeft);
+            }else if(state == 4){
-                    stateName = Utils.TERMINATED;
+                stateName = Utils.TERMINATED;
-                    burst = "0";
-                    break;
-                default:
+                burst = RESET_BURST_TO_ZERO;
+            }else{
-                    stateName = Utils.UNKNOWN_STATE;
+                stateName = Utils.UNKNOWN_STATE;
-                    burst = "0";
-                    break;
+                burst = RESET_BURST_TO_ZERO;
             }
             sb.append(String.format("\t%12s%3s", stateName, burst));
         }
         System.out.println(sb.toString()+".");
     }
 
-    public int randomOS(int B) {
-        String next = random_integers.nextLine();
-        if (verbose) {
-            System.out.println("Find burst when choosing next process to run: " + next + " / " + B + "= " + (Integer.parseInt(next) % B));
-        }
-        return 1 + (Integer.parseInt(next) % B);
-    }
 
+
     public void printFinalSummary() {
         int finishingTime = 0;
+
         double cpuUtilization = 0;
         double throughput = 0;
-        double avgTurnaroundTime = 0;
-        double avgWaitTime = 0;
+        double averageTurnAroundTime = 0;
+        double averageWaitTime = 0;
         double ioUtilization = 0;
 
-        int i = 0;
+        int i;
 
-        System.out.println("The scheduling algorithm used was " + this.name);
-        System.out.println();
-
         for (i = 0; i < numProcesses; i++) {
             System.out.println("Process #" + i + ": ");
             Process_RR p = processes.get(i);
-            System.out.println(p.results());
-            System.out.println();
+            System.out.println(p.summary()+"\n");
 
-            finishingTime = (p.getFinishTime() >= finishingTime) ? p.getFinishTime() : finishingTime;
-            avgWaitTime += p.getTotal_ReadyState_Time();
-            avgTurnaroundTime += p.getTurnaroundTime();
+
+            finishingTime = (p.finishTime >= finishingTime) ? p.finishTime : finishingTime;
+            averageWaitTime += p.total_ReadyState_Time;
+            averageTurnAroundTime += p.turnaroundTime;
             throughput = (100.0/finishingTime) * numProcesses;
             cpuUtilization += p.C;
         }
 
-        avgTurnaroundTime /= i;
-        avgWaitTime /= i;
+        averageTurnAroundTime /= i;
+        averageWaitTime /= i;
+
         ioUtilization = ((double)totalIoBlockCycles/finishingTime);
         cpuUtilization /= finishingTime;
 
         System.out.println("Summary Data: ");
         StringBuilder sb = new StringBuilder();
-        NumberFormat f = new DecimalFormat("#0.000000");
+        NumberFormat f = new DecimalFormat("#0.0000000");
+
         sb.append("        ");
-        sb.append("Finishing Time: " + finishingTime);
-        sb.append("\n        ");
-        sb.append("CPU Utilization: " + f.format(cpuUtilization));
-        sb.append("\n        ");
-        sb.append("I/O Utilization: " + f.format(ioUtilization));
-        sb.append("\n        ");
-        sb.append("Throughput: " + f.format(throughput) + " processes per hundred cycles");
-        sb.append("\n        ");
-        sb.append("Average turnaround time: " + f.format(avgTurnaroundTime));
-        sb.append("\n        ");
-        sb.append("Average waiting time: " + f.format(avgWaitTime));
+        sb.append("Finishing Time: " + finishingTime+Utils.NEWLINE_SPACE);
+        sb.append("CPU Utilization: " + f.format(cpuUtilization)+Utils.NEWLINE_SPACE);
+        sb.append("I/O Utilization: " + f.format(ioUtilization)+Utils.NEWLINE_SPACE);
+        sb.append("Throughput: " + f.format(throughput) + " processes per hundred cycles"+Utils.NEWLINE_SPACE);
+        sb.append("Average turnaround time: " + f.format(averageTurnAroundTime)+Utils.NEWLINE_SPACE);
+        sb.append("Average waiting time: " + f.format(averageWaitTime));
         System.out.println(sb.toString());
+
+        System.out.println("\nPlease Use Command: java {RR, SJF, FCFS, Uniprogrammed} --verbose input.txt ");
     }
 
-    public String getOriginalProcesses() {
-        return originalProcesses;
+    protected ArrayList<Process_RR> sort(ArrayList<Process_RR> processes){
+        Collections.sort(processes, new Comparator<Process_RR>() {
+            public int compare(Process_RR process_A, Process_RR process_B) {
+                if (process_A.A > process_B.A)
+                    return 1;
+                else if (process_A.A < process_B.A)
+                    return -1;
+                else
+                    return 0;
-    }
+            }
+        });
+        return processes;
+    }
 
-    public String getSortedProcesses() { return sortedProcesses; }
+    public int randomOS(int B) {
+        String next = random_integers.nextLine();
+        if (verbose) {
+            System.out.println(Utils.FIND_BURST_WHEN_CHOOSING_NEXT_PROCESS_TO_RUN + next + " / " + B + "= " + (Integer.parseInt(next) % B));
+        }
+        return 1 + (Integer.parseInt(next) % B);
+    }
 
+    protected abstract void updateReadyQueue(); // Abstract method for specific scheduling algorithm to implement
 }
Index: homework/src/HW2/SJF.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/SJF.java	(date 1489030227000)
+++ homework/src/HW2/SJF.java	(date 1489043713000)
@@ -37,21 +37,21 @@
         this.quantum = quantum;
         this.numberOfProcesses = numberOfProcesses;
         for (Process_RR p : processes) {
-            p.setQuantumMax(1000);
+            p.quantumMax = 1000;
         }
     }
 
     protected void updateReadyQueue() {
         Process_RR p = new Process_RR(0,0,0,0);
 
-        p.setTimeRemaining(INTEGER_CONSTANT);
+        p.timeRemaining = INTEGER_CONSTANT;
 
         boolean shouldStop = true;
         for (Process_RR temp : ready) {
 
             if (terminated.contains(temp))
                 continue;
-            if (temp.getCpuBurstRemaining() > 0) {
+            if (temp.cpuBurstRemaining > 0) {
                 return;
             }
             if (temp.timeRemaining < p.timeRemaining) {
@@ -63,7 +63,7 @@
         if (shouldStop)
             return;
 
-        if (!readyQueue.contains(p) && !blockedList.contains(p) && p.getState() != 2)
+        if (!readyQueue.contains(p) && !blockedList.contains(p) && p.state != 2)
             readyQueue.addFirst(p);
 
         ListIterator<Process_RR> i = ready.listIterator();
@@ -71,10 +71,27 @@
 
     public static void main(String[] args) {
 
-        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-6.txt";
+        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-7.txt";
         int quantum = 2;
         boolean verbose = true;
 
+        // java RR --verbose input-6.txt
+        // java RR input-6.txt
+        if(args.length == 2){
+            if(args[0].equals("--verbose")){
+                verbose = true;
+                input = args[1];
+            }
+            else{
+                verbose = false;
+                System.out.println("Please type\n java RR --verbose input.txt or java RR input.txt");
+                System.exit(-1);
+            }
+        }else if(args.length == 1){
+            input = args[0];
+            verbose = false;
+        }
+
         try {
             File inFile = new File(input);
             Scanner scanner = new Scanner(inFile);
@@ -94,11 +111,11 @@
 
             SJF sjf = new SJF(allprocess, quantum, verbose, numberOfProcesses);
 
-            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + sjf.getOriginalProcesses());
-            System.out.println(Utils.THE_SORTED_INPUT_WAS + " " + sjf.getSortedProcesses());
+            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + sjf.originalProcesses);
+            System.out.println(Utils.THE_SORTED_INPUT_WAS + " " + sjf.sortedProcesses);
             System.out.println();
 
-            while (sjf.incomplete()) {
+            while (sjf.terminated.size() < sjf.numProcesses) {
                 sjf.cycle();
             }
             sjf.printFinalSummary();
Index: homework/src/HW2/Uniprogrammed.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/Uniprogrammed.java	(date 1489030227000)
+++ homework/src/HW2/Uniprogrammed.java	(date 1489043713000)
@@ -32,14 +32,31 @@
 
         if (!readyQueue.contains(p) &&
                 !blockedList.contains(p) &&
-                p.getState() != 2)
+                p.state != 2)
             readyQueue.addFirst(p);
     }
 
     public static void main(String[] args) {
-        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-6.txt";
+        String input = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/src/HW2/input_data/input-1.txt";
         boolean verbose = true;
 
+        // java RR --verbose input-6.txt
+        // java RR input-6.txt
+        if(args.length == 2){
+            if(args[0].equals("--verbose")){
+                verbose = true;
+                input = args[1];
+            }
+            else{
+                verbose = false;
+                System.out.println("Please type\n java RR --verbose input.txt or java RR input.txt");
+                System.exit(-1);
+            }
+        }else if(args.length == 1){
+            input = args[0];
+            verbose = false;
+        }
+
         try {
             File inFile = new File(input);
             Scanner scanner = new Scanner(inFile);
@@ -59,11 +76,11 @@
 
             Uniprogrammed uni = new Uniprogrammed(allprocess, verbose, numberOfProcesses);
 
-            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + uni.getOriginalProcesses());
-            System.out.println(Utils.THE_SORTED_INPUT_WAS + uni.getSortedProcesses());
+            System.out.println(Utils.THE_ORIGINAL_INPUT_WAS + uni.originalProcesses);
+            System.out.println(Utils.THE_SORTED_INPUT_WAS + uni.sortedProcesses);
             System.out.println();
 
-            while (uni.incomplete()) {
+            while (uni.terminated.size() < uni.numProcesses) {
                 uni.cycle();
             }
             uni.printFinalSummary();
Index: homework/src/HW2/Utils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- homework/src/HW2/Utils.java	(date 1489030227000)
+++ homework/src/HW2/Utils.java	(date 1489043713000)
@@ -4,10 +4,6 @@
  * Created by lizichen1 on 3/8/17.
  */
 public class Utils {
-
-    public static final String THE_ORIGINAL_INPUT_WAS = "The original input was: ";
-    public static final String THE_SORTED_INPUT_WAS = "The sorted input was:";
-
     //process states
     public static final String UNSTARTED = "unstarted";
     public static final String READY = "ready";
@@ -16,6 +12,11 @@
     public static final String TERMINATED = "terminated";
     public static final String UNKNOWN_STATE = "?";
 
+    public static final String FIND_BURST_WHEN_CHOOSING_NEXT_PROCESS_TO_RUN = "Find burst when choosing next process to run: ";
+    public static final String NEWLINE_SPACE = "\n        ";
+    public static final String THE_ORIGINAL_INPUT_WAS = "The original input was: ";
+    public static final String THE_SORTED_INPUT_WAS = "The sorted input was:";
 
 
+    public static final String RANDOM_NUMBER_FILE = "/Users/lizichen1/Google_Drive/OS_Sp17/homework/input/random-numbers";
 }
Index: homework/src/Test.java
===================================================================
--- homework/src/Test.java	(date 1489030227000)
+++ homework/src/Test.java	(date 1489030227000)
@@ -1,9 +0,0 @@
-/**
- * Created by lizichen1 on 3/3/17.
- */
-public class Test {
-    public static void main(String[] args) {
-        int X = 1804289383;
-        System.out.print(1+X%3);
-    }
-}
